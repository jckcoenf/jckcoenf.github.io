{"pages":[],"posts":[{"title":"学期末以及年末总结","text":"这是本学期（也可以说是本年度）的总结啦。 首先要说的是经过权衡，以前的博客我还是决定放在博客园好了，不搬运到这边来（说实话工程量有点大，并且感觉像是无用功）。 接下来正式说明一下本学期的总结吧。 这学期（大三上）是第一个我认为过得还算可以的学期，抛开了诸多的烦恼，把大部分心思花在了学习上，也有了一些肉眼能看到的成果（尽管只是拙劣的模仿)；我想这大概是找到了自己的兴趣（图形学）的缘故。 但在学习图形学的过程中还是发现了许多的不足，短板。 最大的问题便是学习节奏，耗时太长以OpenGL为例，我从9月份开学初开始便学习图形学，一直学到了12月份上旬（12月份中下旬由于各种报告，以及考试周暂时搁置了），再之后用了一周的时间完成了收尾工作（把LearnOpenGL的实践过了一遍）。并且这还是在跳过了一些PBR教程的基础上。 英语阅读能力的不足。在阅读一些英语文档以及答案教程的时候比较吃力。 数学水准的不足。在看PBR的教程的时候，说实话那些数学推导过程让我很懵逼。 针对以上的不足，提出了一些改进方案。 加快学习节奏。学习一门新知识，无论如何应该将时间限制在2-3个月之内，最好是两个月，最多不超过三个月。时间拉得太长的话我自己也会烦躁（注：同时间段内学习的新知识不应该超过2门，不包括学校开的课程）。这个对时间规划的要求较高。 有意识地阅读英语文档。当然也有在考虑对Learn OpenGL CN进行一部分的校对，以此来提高我自己的阅读水准。 重拾数学。具体来说，学数学分析，因为图形学对微积分以及线代要求较高，因此目前考虑的是先学习数分，而由于目前只是遇到了简单的矩阵变换而已，因此线代的学习会往后拖延。 接下来讲一下下学期（大三下）的规划（当然是除开学校开的课程之外，自己要学习的东西。注：学校开的非水课有计算机网络（必修）以及Linux系统（选修），，我尽量在不占用以下列出的学习规划时间的情况下去学习学校的课程）。 CSAPP。以前学的计算机组成原理也好，一部分操作系统的知识也罢，又或者说汇编语言之类的，始终是没有在脑内形成一个强而有力的结构化、体系化的知识；动手也少，都是仅有理论而缺乏实践。因此我准备通过学习这本经典书籍来重新建立对计算机的认知，当然，与之配套的lab也是不可少的——动手。预计耗时3个月。 计算机图形学基础以及进阶。由于实际上本学期我只是学习了一门图形API，而非真正的图形学本身，因此必须要继续学习下去（寒假打算写个光栅化渲染器雏形，后面会考虑要不要不断完善）。进阶的话打算学习一部分的PBR知识，预计耗时暂定。 微积分和线性代数。上面有提到，在学习PBR之前微积分的知识需过硬，然而不幸的是以前的时候我并没有把心思放在这里，因此需要重新学习。微积分预测需要一个月，线性代数一个月 当然了，有时候我也会对一些杂七杂八的知识感兴趣，比如说博弈论，显示器工作原理之类的，这些东西的学习我就不列入此，因为是非必要的，同时也带有极大的不确定性（时间不确定，学习方式不确定，兴趣不确定）。 还有对于以前知识的完善也不会列出来，因为没啥必要。 PS：年度规划姑且长了一点，我还是做学期的规划吧，把上面那些学了之后也差不多刚好一学期。 当然，上面列出来的只是目前的一个大方向，具体的时间规划还没确定。还有听说数据结构和算法是面试的考核点，我都忘得差不多了，感觉需要重新学习的样子。 顺带说一下寒假需要做的事情好了：光栅化渲染器（雏形）、C++知识补全（类的知识，模板的知识，还有一部分STL容器）。 以上。","link":"/2020/01/13/%E5%AD%A6%E6%9C%9F%E6%9C%AB%E4%BB%A5%E5%8F%8A%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/"},{"title":"first blog in this website","text":"换新博客啦 之前一直是在博客园(jckcoenf)写一些博文，发发牢骚什么的。 现在换成了自建博客(Hexo + Github），托管在Github上。 本想把之前博客园的博客全部导进来的，但是由于我在博客园用的是TinyMCE富文本编辑器，而Hexo只支持Markdown，因此我只能手工一篇一篇慢慢导入了（就当作是练习Markdown语法好了）。 评论区我用的是valine，不用注册账号直接就可以发言的那种 ，删除也是我自己手工删除（好low），不过问题不大，反正写博也是给自己看的。 对了，右下角还有一只看板娘。看别人的博客蛮有趣的，就顺带弄了一只。 以上。","link":"/2020/01/06/first-blog-in-this-website/"},{"title":"光栅化渲染器","text":"光栅化渲染器的实现。 引言图形渲染管线到底干了什么？这是任何一个学习图形学的人都无法逃避的问题。 现代的API（如OpenGL，DirectX等）都将其具体过程封装好了，使用的时候只需传入相应参数，调用函数即可达到渲染的目的。尽管不了解它的原理并不影响使用，但为了编程可持续发展（雾），最好还是自己手动实现一下光栅化渲染器。 以下我简单地阐述图形渲染管线的流程（以OpenGL辅以理解），我会用整体-&gt;细节的结构去阐述这个流程 正文整体首先是一张流传甚广的图片： 这是OpenGL的图形渲染管线（蓝色底代表可编程）示意图，从上我们可以知道图形渲染管线的功能是什么：输入顶点数据，输出屏幕上我们看到的东西。 更加具体一点：输入顶点数据至顶点着色器，接着进行图元装配，（几何着色器可选），然后光栅化（将连续的顶点映射至屏幕，由于屏幕是一个一个的像素（离散的），所以称之为光栅化），接着进行着色，最后进行各种测试和混合（深度测试、模板测试，颜色混合之类的）。 由此，我们知道了图形渲染管线的大致流程，下面开始深入讲解细节。 细节同样是以一张图开局 我们先抛开OpenGL中的那些人为划定的Shader，直接来看渲染管线干了些什么。 Application 这是完全由开发者控制的阶段，通常在CPU上运行，一般是执行一些碰撞之类的计算。此阶段不可再分。 Geometry 这个阶段分为四个小流程，分别是：vertex shading ， optional vertex processing ， clipping， screen mapping。 Rasterization 这个阶段有两个部分，primitive setup和primitive traversal。 Pixel Processing 分为Pixel Shading和Merging。 Geometryvertex shading此阶段有两个任务：计算顶点位置，计算其他属性的值（如法线、纹理坐标，颜色等）。 计算顶点的位置。我们所熟知的model-&gt;view-&gt;projection在这里计算。 具体地说。model变换由三个变换组成：缩放（scale），旋转（rotate），平移（translate），通过矩阵乘法来执行这些操作。（注：rotate用的是四元数而非欧拉角的方式实现，因为欧拉角会导致Gimbal Lock的问题：具体参照 Bonus，四元数和欧拉角之间的转化可以参照图书《3D数学基础：图形与游戏开发》或者quaternion。 接着是view矩阵（即摄像机）。 最后是projection投影矩阵，这个矩阵的推导较为冗长，这里我给出两个推导的链接：深入探索透视投影变换，OpenGL projection matrix，写的都很好。 计算顶点其他属性的值。在计算的过程中要注意透视纹理映射的问题，具体参考：深入探索透视纹理映射（上）, 深入探索透视纹理映射（下）。 optional vertex processing这个阶段是可选的，有曲面细分，几何着色和流输出（图元装配在曲面细分里面），这不是我们阐述的重点。 clipping裁剪过程发生在裁剪空间里面（在执行了model-&gt;view-&gt;projection变换之后，顶点的坐标所处的空间称为裁剪空间）。我们不妨将投影后的点设为$(x, y, z, w)$，此时，不符合 $$\\begin{equation}\\left{ \\begin{array}{lr} -w &lt; x &lt; w &amp; \\ -w &lt; y &lt; w \\ 0 &lt; z &lt; w(OpenGL的话这里是-w &lt; z &lt; w) &amp; \\end{array}\\right.\\end{equation} $$ 的点将会被裁去（裁去之后依据裁剪情况重新组合图元）。 为什么是这个范围？：很简单，在裁剪之后会进行透视除法，将原本perspective构建的视锥体变换到CVV空间(CVV空间中的坐标系称之NDC)中。经过透视除法之后的点(x, y, z,w)变成(x/w, y/w, z/w, 1)，我们知道他们应当处于CVV内，即取值范围为[-1, 1](z在DirectX中是[0, 1]，在OpenGL中是[-1, 1])，我们将这个取值范围逆着推回来即可。此外透视除法会产生近大远小的效果。 裁剪之后便会进行透视除法，将视锥体变成长方体（OpenGL中是正方体），同时产生近大远小的效果。我们也可以说透视除法是要把齐次坐标转回欧式坐标。 screen mapping将处于CVV空间的$(x, y)$坐标映射到屏幕（视口）上（Z坐标作为深度值存储到深度缓冲中）。 这里我们可以知道，如果Perspective的视锥体的Aspect不为1，透视除法之后会失真，而映射到屏幕（视口）上之后会复原（因此我们要把视口的长宽比设置为Perspective 的Aspect一致，这样子映射之后才不会失真）。 Rasterization光栅化有三角形建立和三角形遍历两个阶段。 primitive setup（三角形（图元）建立）：三角形通过传入三个点得以建立。 primitive traversal（三角形（遍历））：遍历三角形内的片元（fragment），送至下一个阶段。 Pixel Processing pixel shading：所有逐像素的计算都在这里完成，光照，纹理，颜色值都是在这里计算。 merging：执行深度测试，模板测试，混合测试等过程。 总结写完了光栅化渲染器，对OpenGL中的图形渲染管线（pipeline）有了初步的理解和认知，尽管实现的只是一个最简单的光栅化渲染器，但以后面对封装好的图形库、游戏引擎的时候总不至于两眼一抹黑。 路还长着呢。 拓展知识 Directx在坐标运算中全程采用的是左手坐标系，OpenGL的NDC是左手坐标系，其他时候都是右手坐标系。 为什么坐标的运算要用到齐次坐标？可以参考这个回答：关于齐次坐标的理解（经典），此外也有另外一种角度，参考：深入探索透视投影变换的开头部分。 参考资料 Bonus quaternion 3D图形固定短线（这个专栏讲的是真的好） OpenGL projection matrix RTR 4th阅读笔记 Chapter2 GPU在进行vertex shading之后，rasterization之前，是怎么剪裁的？——徐行的回答 在透视投影中要进行透视除法。对于这一步 有没有更具体的解释或更形象的类比 让人容易理解？——milo yip的回答","link":"/2020/02/27/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"},{"title":"拆解问题的能力","text":"算是这些天来的一些学习心得吧，当然也想发发牢骚。 近日来的一些编程工作，让我较为深刻地体会到拆分问题是一个很重要的能力。 当在通过阅读一些他人的源码并加以学习改进的时候，首先便要对源码的大体走向，各部分实现的功能（或者说是写的啥）有一个大概的了解；而不是上来就从头到尾阅读下去，沉沦在技术细节中。 在大致了解程序之后，接下来便是拆，根据功能将源码拆分成很多小部分；然后是学，合理地规划时间，不断地去解决问题（或是技术问题，或是数学知识之类的），钻牛角尖。 详细学习完了源码之后，还需要翻回来，重新阅读程序源码，这个时候可以带入技术细节去观看。 对源程序有了足够的了解之后，便可以尝试着自己也造一下轮子了，不求有多么独立创新，但也不能照着全抄。可从代码结构优化，重构的角度出发，去试着优化一下程序源码；更进一步的话可尝试着去添加一些新功能。","link":"/2020/02/17/%E6%8B%86%E8%A7%A3%E9%97%AE%E9%A2%98%E7%9A%84%E8%83%BD%E5%8A%9B/"},{"title":"二极管和三极管的工作原理","text":"不务正业系列（二）。 提示:了解这些知识并不会对编程能力造成什么实质性的影响，充其量只是为了满足自己的求知欲：每天同电脑打交道，连计算机的元器件原理都不知道的话会感觉怪怪的。 引言由于外面疫情较严重，呆在家里好些天了，百无聊赖之际翻起了书，看到有关于门电路的知识，突然想起了以前的一个疑问：门电路的内部电路是怎么样的？它所需要的元器件是什么？ 抱着这样的疑问，我找了很多的参考资料，最终明白了“与或非”门电路的内部组成。 下面我试着从门电路中最基础的东西：二极管和三极管（晶体管）说起。 前置知识 半导体，有本征半导体，N（negative)型半导体， 以及P(positive)型半导体。（注意将半导体和二极管区分开。半导体的名字由来是因为它的导电能力介于绝缘体和导体之间，而二极管是由N型半导体以及P型半导体构成的）。 载流子。在半导体中，载流子有两种，一种称之为空穴， 另外一种为自由电子。自由电子不必多说；空穴是什么呢？在固体物理学中，如果共价键上流失一个电子，最后在共价键上留下空位的现象称之为空穴（例子如下）,它呈现正电性： 相反的，N型半导体多出一个自由电子，它呈现负电性。 正文二极管二极管由一个N型半导体和一个P型半导体组成，如下 自然而然，由于存在空穴浓度差（也可以说是电子浓度差），因此在交界面，P型半导体和N型半导体会产生扩散运动，P区中的空穴向N区运动（我们习惯性地说空穴运动，但是实际上空穴只是个概念性质的东西，它是对电子运动的一种等效，其实就是大量电子运动的等效反方向运动。因此我们也可以把这个说法换成：N区的电子向P区移动）。 N区的电子向P区扩散之后（也即P区的空穴向N区扩散之后），N区原本的氮组元素失去了一个电子而呈现正电性，P区的硼组元素得到了一个电子而呈现正电性，于是不能移动的氮组元素和硼组元素之间就会产生一个内电场（如下）： 这个内电场会阻碍空穴（电子）的扩散，使其达到平衡，并在交接处形成一定厚度的区域，这个区域我们称之为PN结，也叫耗尽区。 接下来的就很简单了，如果我们加上正向电压（P接+ N接-），那么这个内电场就会被削弱（耗尽区也会变窄，原因查看这里：PN结正向偏置的时候为啥空间电荷区（耗尽区）会变窄-汤乐天的回答），从而导通；如果加上反向电压（P接- N接+）那么内电场会被进一步加强（耗尽区变宽），从而截止。 三极管（NPN为例）知道了二极管的原理，那么三极管的原理（也称为晶体管）就很简单了。然而按照原理顺序照本宣科未免也太无趣，这里我尝试着“反着”说回来（这里的“反”其实指的是与国内的教材相反，国内教材总喜欢上来就一堆公式，一堆示意图，学完之后难免一脸懵逼）。 三极管的作用是什么？ 如果你尝试着直接Google或者看书，它们都会告诉你三极管的作用是放大电流。放大电流？听起来似乎不错，但你要知道万物都遵循能量守恒：能量既不会凭空消失也不会凭空产生；同样，这里的放大电流不是真的说无缘无故将电流放大——实际上，三极管的作用是调节电流。举个例子，三极管的原理类似于水龙头，阀门相当于三极管的Base端，水龙头出水的部分相当于Emitter端，水管相当于Collecter端，你总不能说水龙头的作用是放大水流吧，（阀门）调节水流才是正解。 在外语文献中，放大这个词是带有双引号的，从侧面说明它不是真正的放大作用。而国内引入的时候可能把它给漏了，也就沿用至今了。 为什么要有三极管？ 上面有说到水龙头的例子，三极管大致就是这样起作用的。那么三极管的存在意义也就很明显了，当我们需要同一个东西完成多项任务（在三极管这里是调节电流）的时候，三极管就显得很有必要。 三极管的具体原理？ 经过了前面的铺垫，这里就可以开始讲三极管的工作原理了，但我并不打算过分深入地去探究这个东西（毕竟不是电子专业的），浅浅地解析一下便可。如果要深入，可以去读模电，以及固体物理。在后面的参考资料部分也会列出一部分相关参考资料链接。 以NPN三极管为例，如图 在未接入电路前： 从上面的二极管知识我们可以知道，一个NPN三极管拥有两个PN结（当然上图没画出来） 现在接入电路中： 在集电极C端和基极B端分别加上电源电源正极（即发射极正向偏置，集电极反向偏置），那么我们可以知道电子的走向，如下： 从电子的角度来看：靠近发射极E的N端（N发射区）（上图右边黄色区域）中的电子，由于它靠近电源负极，同性相斥，故而被排斥到中间的P基区，到达P基区后，其中少量一部分电子和P基区内的空穴中和（再之后这部分电子慢慢移动到基极B，形成回路）。到达中间的P基区后，由于从发射区N出来的电子较多，未被P基区完全中和；因此剩下的部分在电场的作用下继续向靠近集电极C的N端（N集电区）（上图左边橙色区域），并从集电极C端出来。 从空穴的角度来看：与之相反啦（doge），懒得再写一遍了。不过可以提一下在这之中的一些相关概念。 ​ 开启电压：刚好让空穴通过耗尽区的电压。 ​ 本征激发：核外电子通过获得外界能量而可以摆脱原子核对它的束缚，原子核失去了电子就多一个空位，此时整个“原子”对外带正电，相当于空穴，原子所处的空间中也多一个有了能量就happy的电子。这种三极管内的现象叫做本征激发。也就是说，两侧的N极整体带负电，但其中也存在着空穴——正是由于本征激发。 说了这么多，基极到底是如何调节电流变化的呢？为什么基极微小的电流变化，会引起集电极较大的电流变化？ 首先要明确的是NPN三极管中，P区很薄，空穴的浓度很低，所以从发射极E扩散过来的电子只有很少一部分被中和（并在之后在正极的吸引下往基极B跑，形成回路电流），更大的部分都扩散到了集电极（由于反向偏置）。 当基极电流增大（电压也略微提高）的时候，会引发发射极更多地向基区扩散电子，但仍然由于基区很薄，留下的电子数量很少。多余的电子还是被集电极吸引了。 P区尺寸很小且空穴浓度很低、发射极电子浓度很高及集电极尺寸较大这样四个内在因素，加上集电极正电源的吸引力这样一个外部条件，最终使集电极电流是基极电流的很多倍，这就是人们通常所说的电流放大能力。 值得注意的是，三极管的放大因子（能力）β出厂的时候就做好了。 总结我们可以将一个较小的信号量接入基极B，然后由于所谓的“放大”（β倍），便可以得到一个大的信号量。 二极管是三极管的基础，三级管是现代信息社会的基础。 拓展知识另外看二极管的历史时还拓展了一部分的电路小知识，作为拓展，这里再提两句好了。 高压输电线采用的是三相电，所以不需要零线，只要一条火线就够了。具体参考这里：为什么高压输电线只有火线没有零线？-SamsonHe的回答 采用交流电是为了更加方便地节省传输过程中的电能损耗。根据$P = I^2 * R$可知，传输电的时候降低电流大小就可以达到降低损耗的目的，而根据$U_1I_1 = U_2I_2$即可知道提升次级线圈的电压就可达到降低电流的目的。即采用升压变压器。 值得一提的是，直流电其实也可以升压，但是升压的方法较为复杂，而交流电升压降压都比较简单，这是交流电得以流行的一个缘由。 更加具体的解说可以参考这里：家用交流电的电流方向是怎样的？-Patrick Zhang的回答 参考资料 如何亲手造一台电脑？（二）晶体管与集成运算器 - Catpub 注：上面的所有配图均来自于本篇文章的作者Catpub的个人主页)。 半导体知识工程笔记之二极管类器件 - 每日硬知识 如何形象生动的让初中学生理解三极管的工作状态 - Oxisliant的回答 PN结正向偏置的时候为啥空间电荷区（耗尽区）会变窄-汤乐天的回答 为什么高压输电线只有火线没有零线？-SamsonHe的回答 家用交流电的电流方向是怎样的？-Patrick Zhang的回答 三极管放大原理 - 安全护航9的回答","link":"/2020/02/11/%E4%BA%8C%E6%9E%81%E7%AE%A1%E5%92%8C%E4%B8%89%E6%9E%81%E7%AE%A1%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"title":"门电路的具体构成","text":"不务正业系列（三） 提示：了解这些知识并不会对编程能力造成什么实质性的影响，充其量只是为了满足自己的求知欲：每天同电脑打交道，连计算机的元器件原理都不知道的话会感觉怪怪的。 引言接着上一篇博文（二极管和三极管的工作原理），来简单阐述一下与或非门的具体结构。 正文让我们试着回忆一下与或非门的功能： 与门：全1为1，有0为0。 或门：有1为1，全0为0。 非门：有1为0，有0为1。 看起来的确很简单，难以想象这种东西组成了计算机并且实现了这么复杂的功能。不过我在这里并不打算写计算机那些复杂的功能是怎么实现的，想要了解的话可以去读一读《数字逻辑》。 那么下面就直接上门电路的示意图了（图片依旧来自于知乎用户 Catpub，感谢一波，我比较懒，就不画了（doge））。 与门 如上是与门电路的示意图，它由两个输入端，两个二极管，一个输出端以及一个固定电源，一个电阻组成。 当A或者B输入端（或者两个一起）的电压（电信号）都为低电平时（可以假设为0V，但不一定要0V，只要足够低就行），很容易知道二极管正向偏置，处于导通状态（一般二极管的压降约为0.7V），那么输出端F得到的结果也是0.7V。 为什么是0.7V？首先两个二极管是并联的，那么加在两个二极管之间的电压应该是相等的，二极管左侧的电压为0，压降为0.7V，容易知道二极管右侧电压为0.7V，而输出端F和二极管右侧可以认为是直接导通的，不存在电压下降，因此输出端F的电压等于二极管右侧电压（电源剩下其他的电压加在电阻两边了）。 只有当A和B端的电压较高的时候（此时二极管反向偏置），二极管处于不导通的状态，此时输出F的电压可视为电源串联电阻之后电阻下侧的电压。 或门 如上，有两个输入端，两个二极管，一个输出端，一个电阻接地。 当输入端A和B都为低电平（低电压）（低于0.7V）的时候，因为激发电压的存在，二极管不导通，此时输出端F为0V。 当输出端中有一个以上端口为高电平（高电压）的时候，二极管导通，输出电压为高电平。 非门非门用的不是二极管，而是三极管。 如上，非门电路有一个输入端，一个输出端，两个电阻，一个三极管（E端接地），还有一个电源。 当输入端A的电压很低的时候，我们知道，三极管的基极电压很低的时候是无法驱动的，也就是处于关闭状态，很明显此时输出端F的电压较高。 而当输入端A的电压较高的时候，三极管处于导通状态，此时输出端的电压和接地端一样，也就是0V。 总结以上就是与或非门的具体构成，当然我只是简单地阐述了一下，如果想要详细地了解还是得去读《模拟电路》。 拓展知识事实上，一开始的门电路并不是由二极管和三极管组成的，而是采用一个更加常见的东西：继电器，当时哈佛大学与IBM合作制作的Havard Mark I、Mark II计算机就是用继电器实现的。 我们熟知的第一台通用计算机ENIAC并不是采用继电器来实现门电路，而是用真空管，但真空管也有坏处，例如价格昂贵、耗电高、发热大、寿命短。于是慢慢被二极管和三极管替代。 参考资料 如何亲手造一台电脑?（三）门电路与数字逻辑 - Catpub","link":"/2020/02/12/%E9%97%A8%E7%94%B5%E8%B7%AF%E7%9A%84%E5%85%B7%E4%BD%93%E6%9E%84%E6%88%90/"},{"title":"显示器的工作原理（LCD为例）","text":"不务正业系列（一）。 提示：了解这些知识并不会对编程能力造成什么实质性影响，充其量只是为了满足自己的求知欲：每天同电脑打交道，连一些外设的原理都不知道的话会感觉怪怪的。 引言其实学习图形学以来，我都对图形的生成有一些疑惑，那就是：显示器究竟是怎么将结果显示出来的，它究竟是如何知道我们想要表达出来的颜色并将其表示出来，下面会阐述其原理。 前置知识首先我们要知道人眼是如何辨别颜色的： 光线通过眼睛之后投射到视网膜上，感光细胞（rod&amp;cone）把光信号转化成电信号，再由视神经传导至视觉中枢进行进一步处理，最后形成视觉。 而视锥细胞（cone）有三种，分别是S-视锥细胞，M-视锥细胞和L-视锥细胞，这也就是三基色（RGB）的由来。 具体的讲解参照：视锥细胞是如何辨别感知颜色的-Llenlleawg的回答 我这里就不展开讲了,毕竟我的知识来源也是这些回答，视频，以及其他一些相关文献，而他们也都写得很好，专业素养很高。 正文说完了颜色是如何传入人眼的，接下来就讲显示器的构造原理。 如上（图片来源见水印）。上述各个部件的作用我这里不再赘述，直接参考这个作者的文章：LCD的工作原理是怎样的即可。 总的来说。当我们点亮屏幕的时候： 位于屏幕一侧（通常是底部）LED灯发出白光，经过导光板的反射，使得线光源转化成面光源（使其均匀发光）。 扩散膜让光更加柔和（就像透过毛玻璃看灯泡那样，毕竟直接的光源还是太刺眼了）；棱镜膜使得光大致地往正确地方向走（之所以让其往正确的方向走，是因为一般来讲人都是正对着屏幕的，其他一些大角度的我们不需要，可以让这些不需要、不符合角度的光线反射回去，接着被反光板回收，重新利用，以此来提高光线利用率)。 接着底部偏光片过滤掉水平偏振光（关于偏振光的知识可以参照这里：如何通俗易懂地解释光的偏振-ace zh的回答），只让垂直方向的偏振光通过。 然后TFT根据需要，控制各个子像素（注意是子像素，不是像素，一个像素由三个子像素组成）电压的大小，以此来影响液晶分子的扭曲程度，进而影响最终屏幕上子像素的亮度。（还有一个公共电极，是用来维持整个像素的电压（也可以说是整体亮度）的）。 光穿过液晶，穿过彩色滤光膜。最后一层顶部偏光片只允许水平方向的偏振光通过（这里提一下吧，由于光是往各个方向传播的，偏光膜的作用就是过滤，只留下特定方向的光）。 成功显示。 以上就是LCD屏幕的显示过程，核心要点便是TFT通过电压来操控液晶分子，以此达到控制子像素亮度的目的。 知道显示器的原理之后就很简单了，我们只需要将特定的电压信号输入给显示器，就可以显示出特定的颜色，做出酷炫的动画效果。 至于这电压信号是怎么来的，就涉及到了数模转换。简单地说就是CPU把图像数据送往GPU，GPU处理完数据（软渲染，数模转换）之后再将这模拟信号送到显示屏（具体CPU是怎么获取图像数据的，GPU怎么处理数据的这里并不展开讲，不是本篇的重点）。 拓展知识 我们屏幕上的一个像素点是由三个子像素（对应三个滤光片）组成的。由于一个像素极其小，三个滤光片距离极其近，以至于透过它们的光进入人眼后，人眼分不清这是3束光，即光在人眼中发生混色作用，于是一个像素便有了颜色（具体参照：数据的流动：计算机是如何显示一个像素的）。 现在市场上的OLED屏幕不是依靠背光的，它的红绿蓝子像素是可以自行发光的，像小灯泡那样（也由此可能会引发一些所谓的“烧屏”现象，因为它自行发光的子像素的寿命不一致）。 总结事实上无论是何种显示器，CRT也好，LCD、OLED也罢，核心都是通过电信号来操控电压，以此影响子像素的亮度，不管构造怎么变，技术，材料怎么革新，始终是离不开这一点的。 参考资料 LCD的工作原理是怎样的 如何通俗易懂地解释光的偏振 数据的流动：计算机是如何显示一个像素的 视锥细胞是如何辨别感知颜色的","link":"/2020/01/22/%E6%98%BE%E7%A4%BA%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88LCD%E4%B8%BA%E4%BE%8B%EF%BC%89/"},{"title":"三月份的计划","text":"并不清楚未来会如何，只是做好眼下的事情。 首先，3月份，距离9月份开始的秋招只有半年的时间，这半年的时间不可能面面俱到。 那么我需要先明确我的目标 游戏程序员 很显然，如果要去面试，那么计组数据结构算法计算机网络是必不可少的（基础），而岗位相关部分呢？计算机图形学知识-&gt;游戏demo（以计算机图形学为主，游戏demo为辅） 图形学的知识要按照什么样的顺序去学习?2月份过完年之后我实现了光栅化渲染器，整个三月份学习Ray Tracing的相关知识，四月份开始会完补《fundamental。。。》那本书（主要是没有去系统地学习）。 游戏方面会从4月份开始学习unity3D（大概，到时候还是得看具体进度） 本月的重点： Ray Tracing，会将大部分的时间花在光线追踪渲染器上。 计算机网络，看网络的那本书籍","link":"/2020/02/28/%E4%B8%89%E6%9C%88%E4%BB%BD%E7%9A%84%E8%AE%A1%E5%88%92/"},{"title":"光线追踪渲染器（一）","text":"这是光线追踪渲染器（一）的总结 引言对于计算机图形学的学习正在渐渐地步入正轨。现在开了一个新坑：光线追踪渲染器，使用的教程是Peter shirley写的Ray Tracing in one weekend series，包括Ray Tracing in one weekend， Ray tracing in next week以及Ray Tracing the rest of your life，不过我只打算阅读前两个教程（目前完成了第一个教程），听闻第三个教程质量一般。 那么什么是光线追踪？我想这篇回答可以解答一些疑惑：一篇光线追踪的入门。 下面的正文部分我尝试概述一下Ray Tracing in one weekend的知识。 正文### Chapter １－３ Chapter 1是overview导读,没啥好说的。 Chapter 2说明此次使用的图片的输出格式：ppm，ppm的具体格式如下。值得一提的是，有一些图片编辑器是可以直接打开ppm格式的图片的（如Honeyview）；或者我们可以将其写入到PNG里面：极简的PNG编码函数svpng()；当然用各种第三方图形库也是可以的（如stb_image，但感觉像是杀鸡用牛刀） Chapter 3把所需要用到的数学计算封装成了一个类。 Chapter 4Chapter 4建立起了一个简单的光照雏形。具体地说： 建立射线Ray的概念：$p(t) = A + t * B$（A = origin， B = direction，t为未知数，也即判定hit之后的解） 建立右手坐标系以及平面 Chapter 5由球的一般方程引出了如何在平面上表示一个物体：射线$p(t)$无解说明射线hit不到球，一个解对应一个相切点，两个解对应两个相交点。之后我们可以让hit判定成功的点输出另外一种颜色，这样子就可以看到构建的球的平面图形了。 Chapter 6封装一个抽象类，方便渲染多个物体。并且为了使得hit判定合理（不重复判定被遮挡的物体），每次hit之后都会更新$t$的最大值（此时t最小值为0，但实际上如果为0的话由于浮点运算的精度容易出现自相交问题，因此需要稍微增大一点）。 值得注意的是，作者在这里采用了虚函数。 Chapter 7这里讲述了如何解决物体边缘锯齿的问题：我们通过可以对一个像素进行多次采样再平均（SSAA）的方式，解决锯齿的问题。 为什么这样子可以解决锯齿的问题呢？很简单，锯齿是出现在物体边缘的，主要是因为和背景色差异太大，导致锯齿。我们只需要将背景色和边缘进行“一点点”的融合，就可以将物体边缘很好地过渡到背景。 Chapter 8 - 10这三章讲的都是材质，如何去体现物体的材质。 对于磨砂材质，表面凹凸不平，射线Ray hit判定到之后会进行漫反射。 对于金属材质，表面比较光滑，射线Ray hit判定到之后会进行反射。 对于电介质，则会发生折射。 我们根据这三者的光学现象的不同写出反射/折射后的方程式即可。需要注意的是，只有多个物体的时候才能体现出来这些材质，单个物体是体现不出来的。 为什么？我想可以从结果来说明： 如上图，左边和右边的都是金属球，中间的是磨砂球；以左边的金属球为例子，上面呈现的有背景色，地面色（实际上是个大球的表面），还有磨砂球的倒影。这些都体现了这个球是金属材质。 这里还有个问题，那就是这些倒影是怎么产生的？其实和颜色的计算方式有关。我们采用的是基于背景色，并衰减* 递归的方式计算像素点的颜色值。以金属球为例，射线从camera出发射向金属球， hit成功之后发生衰减并反射，之后反射的射线从第一次hit到的点出发，hit到磨砂球上并发生衰减，然后又从磨砂球hit点出发……如此往复循环，直到最后不再hit。 很明显，由于衰减系数的存在，会使得金属球上的像素点颜色受到周围材质的影响，整体上便表现为倒影了（我认为这和我们多重采样下漫反射的反射方向等概率也有一定关系）。 Chapter 11 - 12Chapter 11讲的是Camera，基本上和光栅化渲染器的没有区别。 Chapter 12是散焦模糊，也就是摄影中“景深”的概念，对于这里我并不是很了解根本原理，只能从表象去说明它：我们之前发射射线一直是从一个点出发，这和实际上的摄像机模型不符合，摄像机透镜是一个圆盘，因此我们需要模拟它，让射线从一个圆盘随机射出（由于多次采样，所以不用担心概率问题，都是等概率的）。 Chapter 13完成题图（狗头）。 总结以上我只是很简单地过了一遍，不能作为任何参考。 此次学习还是大有所获的，毕竟第一次接触光线追踪，从无到有嘛。但我认为one weekend这个教程讲得似乎不够详细，更多的是让初学者快速建立起对光线追踪的概念。 参考资料 一篇光线追踪的入门。 极简的PNG编码函数svpng() 此外有个博主写关于one weekend的“问题系列”还可以（略有瑕疵），这是他的个人主页：图形跟班","link":"/2020/03/12/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E6%B8%B2%E6%9F%93%E5%99%A8/"},{"title":"没有意义的人生","text":"渐渐地意识到，人生没有任何意义。 想说些什么，但字却像卡在喉咙口一般吐不出来。 一切都不可避免地，在走向庸俗","link":"/2020/03/13/%E6%B2%A1%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E4%BA%BA%E7%94%9F/"},{"title":"BVH树的构建","text":"本篇文章把 BVH 的代码结构写一下。 引言为什么要引入BVH（Bounding Volume Hierarchies 层次包围盒）？ 在之前，我们每发出一条射线就要进行许多次的求交运算（和渲染的物体数量成正比，也就是说时间复杂度$O(n)$）；求交命中了还好，要是求交点不中，就相当于之前所作的运算全白费了（大概率是命中不了）。在这种情况下渲染时间就会变得超长。 在此背景下引入了一系列的算法优化，其中一个就是BVH。 具体来说，BVH的核心思想就是用体积略大而几何特征简单的包围盒来近似描述复杂的几何对象，并且这种包围盒是嵌套的，我们只需要对包围盒进行进一步的相交测试，就可以越来越逼近实际对象（很明显这个功能需要用到树形的层次结构）。 下面我尝试详细地写一下BVH的构建过程。 正文求交首先我们需要将场景中的物体全都容纳在一个大的包围盒里面。然后再进一步细分。我们不妨设置一个简单的长方体包围盒（2D）。 假设此时存在一条射线，我们怎么去判断这条射线和包围盒有没有相交？（当然是用眼睛看=_=）我想下图已经很明白了：拿出一个包围盒，延长它的边线，得到一个像“＃”一样的图形。如果射线与包围盒相交，那么对应的t值区间是有重叠（overlap）的，如果不相交，则没有重叠。（当然还有别种方法检测是否重叠） 给出代码： 12345678910111213141516171819bool hit(const ray&amp; r, float tmin, float tmax) const{ for(int a = 0; a &lt; 2; a++) //two axis { float invD = 1.0f / r.direction()[a]; //note: operator[] is overloaded //according to the formula: P(t) = origin + direction * t float t0 = (bounding_box.min()[a] - r.origin()[a]) * invD; //multiplication is //faster float t1 = (bounding_box.max()[a] - r.origin()[a]) * invD; //t0 must less than t1 if (invD &lt; 0.0f) std::swap(t0, t1); tmin = (tmin &gt; t0) ? tmin : t0; tmax = (tmax &lt; t1) ? tmax : t1; if (tmax &lt;= tmin) //\"=\" :if wiped the edge, it is defined as missed return false; } return true;} 倘若不明白，可以跟着代码走一遍。 上面代码还有需要注意的地方，也就是当r.direction平行于轴的时候： t0和t1都会同时为正无穷或者负无穷（因为有+0和-0），我们通过设置最大最小值来解决这个问题。这也就是一开始需要传入tmin和tmax的原因。 在r.direction平行于轴的前提下，如果origin位于包围盒边缘，即： 123bounding_box.min()[a] == r.origin()[a];//orbounding_box.max()[a] == r.origin()[a]; 我们会得到NaN（not a number)，这种情况下，由于任何与NaN的比较都会返回false，因此tmin和tmax的比较也会返回false，此时我们当作它hit成功。 创建Bounding box这个比较简单，直接给出源码： 对于sphere类： 123456bool bounding_box(float t0, float t1, aabb&amp; box) const{ box = aabb(center - vec3(radius, radius, radius), center + vec3(radius, radius, radius));}//t0, t1 in there is not used, just because of pure virtual function in the class//of hittable 对于moving sphere类： 123456789bool bounding_box(float t0, float t1, aabb&amp; box) const{ //center(t) is a function that the center of the sphere change over time aabb box0(center(t0) - vec3(radius, radius, radius), center(t0)+ vec3(radius, radius, radius)); aabb box1(center(t1) - vec3(radius, radius, radius), center(t1) + vec3(radius, radius, radius)); box = surrounding_box(box0, box1);} 包围两个盒子的盒子： 12345678910111213inline float ffmin(float a, float b) { return a &lt; b ? a : b};inline float ffmax(float a, float b) { return a &gt; b ? a : b};aabb surrounding_box(aabb box0, aabb box1){ vec3 small(ffmin(box0.min().x(), box1.min().x()), ffmin(box0.min().y(), box1.min.y()), ffmin(box0.min().z(), box1.min.z())); vec3 big(ffmax(box0.max().x(), box1.max().x()), ffmax(box0.max().y(), box1.max().y()), ffmax(box0.max().z(), box1.max.z())); return aabb(small, big);} 构建bounding box列表（嵌套box） 1234567891011121314151617181920212223bool bounding_box(float t0, float t1, aabb&amp; box){ if(list_size &lt; 1) return false; aabb temp_box; bool first_true = list[0]-&gt;bounding_box(t0, t1, temp_box); //Polymorphism,it will //call the sphere or moving_sphere's bounding_box if (!first_true) return false; else box = temp_box; for(int i = 1; i &lt; list_size; i++) { if(list[i]-&gt;bounding_box(t0, t1, temp_box)) box = surrounding_box(box, temp_box); else return false; } return true;}//this function will be called at BVH construction 创建BVH树这里大概是最麻烦的地方了=_= 首先给出BVH类的整体实现： 12345678910111213141516171819class bvh_node : public hittable{public: bvh_node(){}; bvh_node(hittable **l, int n, float t0, float t1); virtual bool hit(const ray&amp;r, float tmin, float tmax, hit_record&amp; rec) const; virtual bool bounding_box(float t0, float t1, aabb&amp; b) const; hittable* left; hittable* right; aabb box;}//return itselfbool bvh_node::bounding_box(float t0, float t1, aabb&amp; b) const{ b = box; return true;} 我们需要注意一下child指针left和right，它们的指针类型是hittable ，即通用指针，这就意味着它们可以指向其他的 *bvh_node，或者sphere类，又或者其他继承自hittable类的子类型。这有利于多态实现。 码接上文，先给出bvh_node构造函数的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748bvh_node::bvh_node(hittable **l, int n, float t0, float t1){ int axis = int(3 * random_double()); //random_double will give a number between 0 &amp; 1 //sort if (axis == 0) // x-axis qsort(l, n, sizeof(hittable*), box_x_compare); else if (axis == 1) //y -axis qsort(l, n, sizeof(hittable*), box_y_compare); else qsort(l, n, sizeof(hittable*), box_z_compare); if (n == 1) left = right = l[0]; else if (n == 2) { left = l[0]; right = l[1]; } else { left = new bvh_node(l, n / 2, t0, t1); right = new bvh_node(l + n / 2, n - n / 2, t0, t1); } aabb box_left, box_right; if (!left-&gt;bounding_box(t0, t1, box_left) || !right-&gt;bounding_box(t0, t1, box_right)) std::err &lt;&lt; \"no bounding box in bvh_node constructor\" &lt;&lt; std::endl; box = surrounding_box(box_left, box_right);}int box_x_compare (const void * a, const void * b) { aabb box_left, box_right; hittable *ah = *(hittable**)a; hittable *bh = *(hittable**)b; if (!ah-&gt;bounding_box(0,0, box_left) || !bh-&gt;bounding_box(0,0, box_right)) std::cerr &lt;&lt; \"no bounding box in bvh_node constructor\\n\"; if (box_left.min().x() - box_right.min().x() &lt; 0.0) return -1; else return 1;}//box_y_compare and box_z_compare are just like box_x_compare, so I won't give them. 兴许这里需要详细解释一下： 一开始我们将hittable*** *l 即所有物体进行快速排序，排序依据随机（x y z）； 之后开始构建BVH树： 对于只有一个物体的hittable list ，将左子树和右子树都赋值为这个物体，之后分别调用bounding_box，将左右子树的物体（同一个）外面都用包围盒围起来（实质上是构建一个虚拟盒子），再然后调用surrounding_box将左右子树物体包成一个box。此时左右子树为左右叶子节点。 对于两个物体的hittable list，将左子树赋值为第一个物体，右子树赋值为第二个物体，之后分别调用 bounding_box，将两个物体外面都用包围盒围起来，再然后调用surrounding_box将左右子树物体包成一个box。此时左右子树为左右叶子节点。 对于超过两个物体的hittable list，左子树为新构建的BVH节点，右子树也为新构建的BVH节点，递归下去，直到$n = 2$的时候终止递归（记住在每一个节点中都是先递归左子树再递归右子树）。 终止递归之后，对于$n = 2$，将当前节点的左右叶子节点（左右物体）用bounding_box包围起来，然后包成一个box；执行完之后返回到上一层节点$n = 4$。 返回到节点$n = 4$之后，会开始构建右子树的叶子节点，同样的用bounding_box包围，然后包成一个box； 当节点$n = 4$的右子树也构建完了之后，就会依照运行顺序继续往下运行，也即：调用bounding_box分别将左右子树的两个物体再包一遍（这里调用的bounding_box是bvh_node的，也即返回自身的那个），然后将左右子树的物体包成一个box； 一直这样子持续下去，直到最后变成一个最大的box。 值得一提的是，每次递归，都会导致hittable** l 的局部排序方式改变。 构建完了BVH树之后，接下来就是hit函数的判定了，同样先给出代码： 123456789101112131415161718192021222324252627282930313233bool bvh_node::hit(const ray&amp; r, float tmin, float tmax, hit_record&amp; rec) const { //box.hit is the most large aabb's hit--yes, we gave it at the beginning of the article if(box.hit(r, tmin, tmax)) { hit_record left_rec, right_rec; bool hit_left = left-&gt;hit(r, tmin, tmax, left_rec); bool hit_right = right-&gt;hit(r, tmin, tmax, right_rec); if (hit_left &amp;&amp; hit_right) { if (left_rec.t &lt; right_rec.t) rec = left_rec; else rec = right_rec; return true; } else if (hit_left) { rec = left_rec; return true; } else if (hit_right) { rec = right_rec; return true; } else return false; } else return false;} bvh_node::hit函数一开始就调用aabb类的hit函数（用的是最大的box，我们知道当bvh树对象创建好了之后构造函数就会将整个box构建好），当我们hit到了最大的box之后就会继续往下（如果连最大的box都没有hit到的话后面的也不用继续往下判定了，直接返回false就好）； 往下，开始判定左子树是否有hit到东西：如果左子树是一个叶子节点类型，那么就会调用aabb类的hit函数，如果左子树是一个bvh_node节点，那么就会递归调用bvh_node::hit（递归的box显然会随着调用对象的改变而改变，这里是左子树对应的box，而不是root对应的box）。 递归调用直到出现子叶节点，此时对应节点的box调用的hit是aabb类的，hit到最后的子叶节点之后，就会调用具体物体的hit函数了（比如说sphere::hit或者moving_sphere::hit），并且将最后的hit结果保存起来。再之后就开始返回（true or false）到上一层节点，进行右子树的判定，重复这个过程。 后面就简单了，返回hit到的物体（如果两个物体都hit到（即重叠），那么就取最近的那个），对于一条射线来说，一次hit到的物体最多有一个，因此我们不需要存储所有hit_record，只需要一个就行。这就是为啥没用上list的缘故。 以上。 总结一开始理解的话难度来自于多态的应用以及递归函数具体的行为，理解好了它们，构建BVH就很简单了。 参考[1] 【《Real-Time Rendering 3rd》 提炼总结】(十一) 第十四章 : 游戏开发中的渲染加速算法总结","link":"/2020/03/18/BVH%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/"},{"title":"光线追踪渲染器（二）","text":"这是光线追踪渲染器（二）的总结。 引言完成了Ray tracing the next week的学习，对计算机绘制图片有了进一步的理解，当然我深知这还远远不够。 the next week和in one weekend的不同在于：前者可以自由地跳跃阅读，是一块一块的知识点；而后者只能照着顺序阅读下去。我个人认为the next week的质量并不如in one weekend，很多地方也讲得并不是很透彻，不过并不妨碍这是入门光线追踪最好最简单的教程之一。 下面依旧尝试概述一下其中的内容。 正文Chapter1：Overview总括，没啥好讲的。提醒了一下读者BVH和Perlin noise是本书的难点。 Chapter2：Motion BlurMotion blur：运动模糊。在我们的现实世界中，我们可以通过在相机快门的开启时间间隔内移动相机或者移动被拍物体，来造成一种模糊的效果，这种效果就称之为运动模糊。 在光线追踪渲染器中，我们要渲染出这种效果，可以通过添加一个时间变量来解决：创建一个圆心随着时间t改变moving_sphere类，同时重写hit函数即可。 Chapter3：Bounding Volume HierarchiesBounding Volume Hierarchies也就是层次包围盒。我之前写过博客，这里就不赘述了：BVH树的构建。 Chapter4：Solid Texture从这里开始引入Texture（纹理）的概念，所谓的纹理，其实也就是在物体表面设置各种颜色的函数。我们可以简单的通过设置物体表面各处的attenuation参数不相同来实现最简单的纹理效果。 Chapter5：Perlin Noise图形噪声，是计算机图形学中一类随机算法，经常用来模拟自然界中的各种纹理材质。这一章从最基础的value noise讲起，然后慢慢地实现各种效果。但这一章作者讲得不是很好，颇有点让人丈二和尚摸不着头脑，我更加建议看ScratchPixel的对应章节： Value Noise and Procedural Patterns: Part 1 Perlin Noise: Part 2 细得不能再细了。 嫌太长的话可以看个简略版本：如何生成一张 Value Noise 算法图片（包括 Perlin Noise）。 Chapter6：Image Texture Mapping图片纹理映射。我们把一张图片映射至球体上，首先需要获取球体上的点，并将其从球坐标系转化到直角坐标系（直角坐标取值范围是[0,1]）；之后引入stb_image库，加载获取图片的信息，并将对应点（根据前面直角坐标系的uv坐标转化计算出对应点）颜色值作为attenuation值。 Chapter7：Rectangles and Lights首先建立xy_rect， yz_rect， 和xz_rect三个面的类。 可以用一个面类表示光源（Lights）的位置（颜色为白色），光源的属性则为一个新的材质类diffuse light，这个材质不反射光线，全部吸收，同时其emitted函数返回光源的颜色值。 三个面类组成一个可渲染的长方体（Rectangle）（要注意法线方向）。 示意图如上所示，所以的光照效果原理既是如此： 一开始射线hit到球类，然后反射至光源处，前面说过光源是不反射射线的，因此不会继续往下（递归）反射，只会返回光的颜色值，再和球体本身的颜色结合，整体上表现为受到光源影响。 Chapter8：Instances利用chapter7提到的三个面类，我们可以构建一个Cornell Box（再次提醒注意法线方向），之后可在Cornell Box里面渲染长方体或者球。 我们还可以通过坐标变换的方式，移动或者旋转长方体。 （有一点要提出来的，在旋转的函数里面我们先是反着物体要旋转的方向（对应旋转矩阵的转置矩阵）改变射线Ray的origin和direction，进行hit判定之后还需要把hit point的位置和法线方向进行旋转（对应旋转矩阵），以保证之后散射计算正确。如果不懂的话你可以拿着一只笔作为射线和一个物体实验一下，就知道为啥要这么干了） Chapter9： Volumes实不相瞒这里我看不大懂……只说一些自己懂的东西。 体积雾hit判定之后，与diffuse材质最不相同的地方是散射的方向判定，diffuse的散射方向向量指向外相切球体表面，而体积雾的视线方向指向以碰撞点为球心的单位球体表面（也就是说有时候光线可以穿过体积雾）。 Chapter10：A Scene Testing All features渲染场景。 要提出的是，每像素点发射20000条以上的射线才能渲染出像样的图片，不然会有很多噪点。 然而20000条……渲染起来不是一般的久（尽管经过了BVH树的优化），可以考虑开多个程序分开计算的方式缩短时间，然而治标不治本。 我们可以考虑对光线路径和光源本身同时进行采样计算的直接光照和间接光照结合方法优化画质，比上述的暴力法效率更好，具体咋整我还没学到，以后学到了补充过来。 总结光线追踪的学习暂且告一小段的落，后续还会继续往下学习。 参考资料[1] Value Noise and Procedural Patterns: Part 1 [2] Perlin Noise: Part 2 [3] 如何生成一张 Value Noise 算法图片（包括 Perlin Noise）","link":"/2020/03/31/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E6%B8%B2%E6%9F%93%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"}],"tags":[{"name":"生活随笔","slug":"生活随笔","link":"/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"},{"name":"计算机图形学","slug":"计算机图形学","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"拓展知识","slug":"拓展知识","link":"/tags/%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86/"}],"categories":[{"name":"生活随笔","slug":"生活随笔","link":"/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"},{"name":"计算机图形学","slug":"计算机图形学","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"拓展知识","slug":"拓展知识","link":"/categories/%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86/"}]}